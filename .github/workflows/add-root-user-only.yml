name: Add Root User to EKS Cluster Only

on:
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}

jobs:
  add-user:
    name: Add Root User to Cluster
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ env.AWS_ROLE_ARN }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Get cluster name from Pulumi
        id: get_cluster
        working-directory: pulumi-aws
        run: |
          # Intentar obtener el nombre del cluster desde Pulumi outputs
          # Si no funciona, usar un valor por defecto
          CLUSTER_NAME=$(pulumi stack output clusterName 2>/dev/null || echo "todo-cluster-1b2c4b1")
          echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "cluster=$CLUSTER_NAME" >> $GITHUB_OUTPUT

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region "${{ env.AWS_REGION }}" --name "${{ steps.get_cluster.outputs.cluster_name }}"

      - name: Configure aws-auth ConfigMap (add root user for local access)
        shell: bash
        run: |
          set -euo pipefail
          ACCOUNT_ID=$(aws sts get-caller-identity --query 'Account' --output text)
          ROOT_USER_ARN="arn:aws:iam::${ACCOUNT_ID}:root"
          echo "Root user ARN: $ROOT_USER_ARN"
          echo "Current caller identity:"
          aws sts get-caller-identity
          
          # Intentar obtener el ConfigMap actual
          echo "Attempting to get aws-auth ConfigMap..."
          if kubectl get configmap aws-auth -n kube-system -o json > /tmp/aws-auth.json 2>/dev/null; then
            echo "✓ Successfully retrieved aws-auth ConfigMap"
            cat /tmp/aws-auth.json | jq '.data' || true
          else
            echo "⚠ Could not retrieve ConfigMap, creating base structure..."
            echo '{"apiVersion":"v1","kind":"ConfigMap","metadata":{"name":"aws-auth","namespace":"kube-system"},"data":{}}' > /tmp/aws-auth.json
          fi
          
          # Leer los valores actuales
          MAP_ROLES=$(jq -r '.data.mapRoles // ""' /tmp/aws-auth.json)
          MAP_USERS=$(jq -r '.data.mapUsers // ""' /tmp/aws-auth.json)
          
          echo ""
          echo "Current mapUsers:"
          echo "$MAP_USERS"
          echo ""
          echo "Current mapRoles:"
          echo "$MAP_ROLES"
          echo ""
          
          UPDATED=false
          # Agregar el usuario root si no existe
          if [ -z "$MAP_USERS" ] || ! echo "$MAP_USERS" | grep -q "$ROOT_USER_ARN"; then
            echo "Adding root user to aws-auth ConfigMap..."
            NEW_USER_ENTRY=$(printf -- "- userarn: %s\n      username: root\n      groups:\n        - system:masters" "$ROOT_USER_ARN")
            if [ -z "$MAP_USERS" ]; then
              MAP_USERS="$NEW_USER_ENTRY"
            else
              MAP_USERS="$MAP_USERS"$'\n'"$NEW_USER_ENTRY"
            fi
            UPDATED=true
            echo "New mapUsers content:"
            echo "$MAP_USERS"
          else
            echo "✓ Root user already exists in ConfigMap"
          fi
          
          # Actualizar el ConfigMap si hubo cambios
          if [ "$UPDATED" = true ]; then
            echo ""
            echo "Updating ConfigMap..."
            
            # Construir el ConfigMap completo preservando mapRoles
            if [ -n "$MAP_ROLES" ]; then
              # Si mapRoles existe, preservarlo
              jq -n \
                --arg mapRoles "$MAP_ROLES" \
                --arg mapUsers "$MAP_USERS" \
                '{
                  "apiVersion": "v1",
                  "kind": "ConfigMap",
                  "metadata": {
                    "name": "aws-auth",
                    "namespace": "kube-system"
                  },
                  "data": {
                    "mapRoles": $mapRoles,
                    "mapUsers": $mapUsers
                  }
                }' > /tmp/aws-auth-updated.json
            else
              # Si no hay mapRoles, solo crear mapUsers
              jq -n \
                --arg mapUsers "$MAP_USERS" \
                '{
                  "apiVersion": "v1",
                  "kind": "ConfigMap",
                  "metadata": {
                    "name": "aws-auth",
                    "namespace": "kube-system"
                  },
                  "data": {
                    "mapUsers": $mapUsers
                  }
                }' > /tmp/aws-auth-updated.json
            fi
            
            echo "ConfigMap to apply:"
            cat /tmp/aws-auth-updated.json | jq .
            
            # Intentar apply
            if kubectl apply -f /tmp/aws-auth-updated.json; then
              echo "✓ aws-auth ConfigMap updated successfully"
            else
              echo "⚠ Apply failed, trying patch method..."
              MAP_USERS_JSON=$(echo "$MAP_USERS" | jq -Rs .)
              kubectl patch configmap aws-auth -n kube-system --type merge -p "{\"data\":{\"mapUsers\":$MAP_USERS_JSON}}" || echo "⚠ Patch also failed"
            fi
          else
            echo "✓ aws-auth ConfigMap already configured"
          fi
          
          # Verificar que el usuario fue agregado
          echo ""
          echo "Verifying final state..."
          sleep 3
          kubectl get configmap aws-auth -n kube-system -o yaml | grep -A 20 "mapUsers:" || echo "Could not verify"
          
      - name: Verify access
        run: |
          echo "Verifying cluster access..."
          kubectl get nodes || echo "⚠ Could not get nodes (may need to wait a few seconds)"
          kubectl get namespaces || echo "⚠ Could not get namespaces"

