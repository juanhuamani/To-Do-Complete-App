name: Destroy AWS Cluster (GitHub Actions)

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: 'Type "destroy" to confirm'
        required: true
        default: ''

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
  PULUMI_ACCESS_TOKEN: ${{ secrets.PULUMI_ACCESS_TOKEN }}

jobs:
  destroy:
    name: Destroy Cluster
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.confirm == 'destroy' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ env.AWS_ROLE_ARN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: pulumi-aws/package-lock.json

      - name: Install Pulumi CLI
        uses: pulumi/setup-pulumi@v2

      - name: Install dependencies
        working-directory: pulumi-aws
        run: npm ci

      - name: Select Pulumi stack
        working-directory: pulumi-aws
        env:
          PULUMI_ACCESS_TOKEN: ${{ env.PULUMI_ACCESS_TOKEN }}
        run: |
          set +e
          pulumi stack select dev
          if [ $? -ne 0 ]; then
            echo "Stack 'dev' not found. It may have already been destroyed."
            echo "Nothing to destroy. Exiting successfully."
            exit 0
          fi
          echo "Stack 'dev' selected successfully"

      - name: Cancel any in-progress operations
        working-directory: pulumi-aws
        env:
          PULUMI_ACCESS_TOKEN: ${{ env.PULUMI_ACCESS_TOKEN }}
        run: |
          set +e
          echo "Checking for in-progress operations..."
          # Intentar cancelar cualquier operación en progreso
          pulumi cancel || echo "No operations to cancel or already completed"
          # Esperar un poco para que se complete la cancelación
          sleep 5
          echo "Ready to proceed with destroy"

      - name: Remove all Kubernetes resources from state
        working-directory: pulumi-aws
        env:
          PULUMI_ACCESS_TOKEN: ${{ env.PULUMI_ACCESS_TOKEN }}
        run: |
          set +e
          echo "Removing all Kubernetes resources from state..."
          # Método 1: Intentar obtener recursos usando pulumi stack export
          echo "Method 1: Trying to get resources from stack export..."
          pulumi stack export 2>/dev/null > /tmp/stack.json
          if [ -f /tmp/stack.json ] && [ -s /tmp/stack.json ]; then
            echo "Extracting Kubernetes resource URNs from stack export..."
            # Excluir providers de Kubernetes, solo eliminar recursos reales de Kubernetes
            jq -r '.deployment.resources[]? | select(.urn | contains("kubernetes:") and (contains("pulumi:providers") | not)) | .urn' /tmp/stack.json 2>/dev/null | while read URN; do
              if [ -n "$URN" ]; then
                echo "Removing Kubernetes resource: $URN"
                pulumi state delete "$URN" --yes 2>/dev/null && echo "✓ Deleted: $URN" || echo "⚠ Failed or already removed: $URN"
              fi
            done
          else
            echo "Could not export stack, using fallback method..."
          fi
          # Método 2: Fallback - eliminar recursos conocidos problemáticos
          echo "Method 2: Removing known problematic Kubernetes resources..."
          for URN in \
            "urn:pulumi:dev::todo-aws::custom:components:ClusterAutoscaler\$kubernetes:apps/v1:Deployment::cluster-autoscaler" \
            "urn:pulumi:dev::todo-aws::custom:components:ClusterAutoscaler\$kubernetes:core/v1:ServiceAccount::cluster-autoscaler" \
            "urn:pulumi:dev::todo-aws::custom:components:ClusterAutoscaler\$kubernetes:rbac.authorization.k8s.io/v1:ClusterRole::cluster-autoscaler" \
            "urn:pulumi:dev::todo-aws::custom:components:ClusterAutoscaler\$kubernetes:rbac.authorization.k8s.io/v1:ClusterRoleBinding::cluster-autoscaler" \
            "urn:pulumi:dev::todo-aws::custom:components:Kubernetes\$kubernetes:core/v1:Secret::mysql-secret" \
            "urn:pulumi:dev::todo-aws::custom:components:Kubernetes\$kubernetes:core/v1:ConfigMap::backend-config" \
            "urn:pulumi:dev::todo-aws::custom:components:Kubernetes\$kubernetes:core/v1:Namespace::todo-namespace" \
            "urn:pulumi:dev::todo-aws::custom:components:LoadBalancer\$kubernetes:core/v1:ServiceAccount::aws-load-balancer-controller"; do
            echo "Attempting to delete: $URN"
            pulumi state delete "$URN" --yes 2>/dev/null && echo "✓ Deleted: $URN" || echo "⚠ Not found: $URN"
          done
          echo "Kubernetes resources removal completed"

      - name: Clean up AWS residual resources
        run: |
          set +e
          echo "Cleaning up residual AWS resources that may block VPC deletion..."
          
          # Obtener el nombre del cluster desde Pulumi outputs
          CLUSTER_NAME=$(pulumi stack output clusterName --cwd pulumi-aws 2>/dev/null | tr -d '"' || echo "")
          VPC_ID=""
          
          # Método 1: Intentar obtener VPC ID desde el estado de Pulumi
          echo "Method 1: Trying to get VPC ID from Pulumi stack export..."
          pulumi stack export --cwd pulumi-aws 2>/dev/null > /tmp/stack-export.json
          if [ -f /tmp/stack-export.json ] && [ -s /tmp/stack-export.json ]; then
            # Buscar el VPC ID en los recursos de awsx:ec2:Vpc
            VPC_ID=$(jq -r '.deployment.resources[]? | select(.type | contains("awsx:ec2:Vpc")) | .outputs.id // empty' /tmp/stack-export.json 2>/dev/null | head -n1 | tr -d '"' || echo "")
            if [ -z "$VPC_ID" ]; then
              # Buscar en recursos relacionados con VPC (subnets, security groups, etc.)
              VPC_ID=$(jq -r '.deployment.resources[]? | select(.type | contains("aws:ec2/vpc:Vpc") or contains("awsx:ec2:Vpc")) | .outputs.id // .outputs.vpcId // empty' /tmp/stack-export.json 2>/dev/null | head -n1 | tr -d '"' || echo "")
            fi
            if [ -n "$VPC_ID" ] && [ "$VPC_ID" != "null" ]; then
              echo "✓ VPC ID from Pulumi state: $VPC_ID"
            fi
          fi
          
          # Método 2: Obtener VPC ID desde el cluster de EKS (si aún existe)
          if [ -z "$VPC_ID" ] || [ "$VPC_ID" == "None" ] || [ "$VPC_ID" == "null" ]; then
            if [ -n "$CLUSTER_NAME" ]; then
              echo "Method 2: Trying to get VPC ID from EKS cluster..."
              VPC_ID=$(aws eks describe-cluster --name "$CLUSTER_NAME" --query "cluster.resourcesVpcConfig.vpcId" --output text 2>/dev/null || echo "")
              if [ -n "$VPC_ID" ] && [ "$VPC_ID" != "None" ]; then
                echo "✓ VPC ID from cluster: $VPC_ID"
              fi
            fi
          fi
          
          # Método 3: Buscar VPC por nombre del proyecto (todo-vpc)
          if [ -z "$VPC_ID" ] || [ "$VPC_ID" == "None" ] || [ "$VPC_ID" == "null" ]; then
            echo "Method 3: Trying to find VPC by project name (todo-vpc)..."
            VPC_ID=$(aws ec2 describe-vpcs \
              --filters "Name=tag:Name,Values=*todo*vpc*" \
              --query "Vpcs[0].VpcId" --output text 2>/dev/null || echo "")
            if [ -n "$VPC_ID" ] && [ "$VPC_ID" != "None" ]; then
              echo "✓ VPC ID from name tag: $VPC_ID"
            fi
          fi
          
          # Método 4: Buscar VPC por tags de Kubernetes (si el cluster aún existe)
          if [ -z "$VPC_ID" ] || [ "$VPC_ID" == "None" ] || [ "$VPC_ID" == "null" ]; then
            if [ -n "$CLUSTER_NAME" ]; then
              echo "Method 4: Trying to find VPC by Kubernetes cluster tags..."
              VPC_ID=$(aws ec2 describe-vpcs \
                --filters "Name=tag:kubernetes.io/cluster/${CLUSTER_NAME},Values=shared" \
                --query "Vpcs[0].VpcId" --output text 2>/dev/null || echo "")
              if [ -n "$VPC_ID" ] && [ "$VPC_ID" != "None" ]; then
                echo "✓ VPC ID from Kubernetes tags: $VPC_ID"
              fi
            fi
          fi
          
          # Método 5: Buscar VPC por subnets que empiecen con "todo-vpc"
          if [ -z "$VPC_ID" ] || [ "$VPC_ID" == "None" ] || [ "$VPC_ID" == "null" ]; then
            echo "Method 5: Trying to find VPC by subnet names..."
            SUBNET_VPC=$(aws ec2 describe-subnets \
              --filters "Name=tag:Name,Values=*todo-vpc*" \
              --query "Subnets[0].VpcId" --output text 2>/dev/null || echo "")
            if [ -n "$SUBNET_VPC" ] && [ "$SUBNET_VPC" != "None" ]; then
              VPC_ID="$SUBNET_VPC"
              echo "✓ VPC ID from subnet tags: $VPC_ID"
            fi
          fi
          
          if [ -z "$VPC_ID" ] || [ "$VPC_ID" == "None" ] || [ "$VPC_ID" == "null" ]; then
            echo "⚠ Could not determine VPC ID. Will try to clean up resources by cluster name and region..."
            echo "⚠ Note: Some cleanup steps may be skipped without VPC ID"
          else
            echo "✓ Using VPC ID: $VPC_ID"
          fi
          
          # Limpieza agresiva sin VPC ID: buscar todos los recursos relacionados con "todo"
          if [ -z "$VPC_ID" ] || [ "$VPC_ID" == "None" ] || [ "$VPC_ID" == "null" ]; then
            echo ""
            echo "Performing aggressive cleanup without VPC ID..."
            
            # Buscar y liberar todas las Elastic IPs que no estén asociadas
            echo "Cleaning up all unassociated Elastic IPs in region..."
            ALL_UNASSOC_EIPS=$(aws ec2 describe-addresses \
              --filters "Name=domain,Values=vpc" \
              --query "Addresses[?AssociationId==null].AllocationId" \
              --output text 2>/dev/null || echo "")
            
            if [ -n "$ALL_UNASSOC_EIPS" ] && [ "$ALL_UNASSOC_EIPS" != "None" ]; then
              echo "Found unassociated Elastic IPs: $ALL_UNASSOC_EIPS"
              for EIP_ALLOC in $ALL_UNASSOC_EIPS; do
                echo "  → Releasing: $EIP_ALLOC"
                aws ec2 release-address --allocation-id "$EIP_ALLOC" 2>/dev/null && echo "    ✓ Released" || echo "    ⚠ Failed"
              done
            fi
            
            # Buscar Network Interfaces por nombre/tags relacionados con "todo"
            echo "Searching for Network Interfaces related to the project..."
            if [ -n "$CLUSTER_NAME" ]; then
              ENI_IDS=$(aws ec2 describe-network-interfaces \
                --filters "Name=description,Values=*${CLUSTER_NAME}*" \
                --query "NetworkInterfaces[?Status!='in-use'].NetworkInterfaceId" \
                --output text 2>/dev/null || echo "")
              
              if [ -n "$ENI_IDS" ] && [ "$ENI_IDS" != "None" ]; then
                echo "Found Network Interfaces: $ENI_IDS"
                for ENI_ID in $ENI_IDS; do
                  echo "  → Deleting: $ENI_ID"
                  # Intentar desvincular primero
                  ATTACHMENT_ID=$(aws ec2 describe-network-interfaces --network-interface-ids "$ENI_ID" --query "NetworkInterfaces[0].Attachment.AttachmentId" --output text 2>/dev/null || echo "")
                  if [ -n "$ATTACHMENT_ID" ] && [ "$ATTACHMENT_ID" != "None" ] && [ "$ATTACHMENT_ID" != "null" ]; then
                    aws ec2 detach-network-interface --attachment-id "$ATTACHMENT_ID" --force 2>/dev/null || true
                    sleep 1
                  fi
                  aws ec2 delete-network-interface --network-interface-id "$ENI_ID" 2>/dev/null && echo "    ✓ Deleted" || echo "    ⚠ Failed"
                done
              fi
            fi
            sleep 5
          fi
          
          # 1. Eliminar Load Balancers de Kubernetes (ALB/NLB)
          echo ""
          echo "Step 1: Checking for Load Balancers..."
          if [ -n "$CLUSTER_NAME" ]; then
            LB_ARNS=$(aws elbv2 describe-load-balancers --query "LoadBalancers[?contains(LoadBalancerName, '$CLUSTER_NAME') || contains(LoadBalancerName, 'k8s-') || contains(LoadBalancerName, 'todo-')].LoadBalancerArn" --output text 2>/dev/null || echo "")
          else
            LB_ARNS=$(aws elbv2 describe-load-balancers --query "LoadBalancers[?contains(LoadBalancerName, 'k8s-') || contains(LoadBalancerName, 'todo-')].LoadBalancerArn" --output text 2>/dev/null || echo "")
          fi
          
          if [ -n "$LB_ARNS" ] && [ "$LB_ARNS" != "None" ]; then
            echo "Found Load Balancers: $LB_ARNS"
            for LB_ARN in $LB_ARNS; do
              echo "  → Deleting Load Balancer: $LB_ARN"
              # Eliminar listeners primero
              LISTENER_ARNS=$(aws elbv2 describe-listeners --load-balancer-arn "$LB_ARN" --query "Listeners[].ListenerArn" --output text 2>/dev/null || echo "")
              for LISTENER_ARN in $LISTENER_ARNS; do
                aws elbv2 delete-listener --listener-arn "$LISTENER_ARN" 2>/dev/null || true
              done
              # Eliminar target groups asociados
              TG_ARNS=$(aws elbv2 describe-target-groups --load-balancer-arn "$LB_ARN" --query "TargetGroups[].TargetGroupArn" --output text 2>/dev/null || echo "")
              for TG_ARN in $TG_ARNS; do
                aws elbv2 delete-target-group --target-group-arn "$TG_ARN" 2>/dev/null || true
              done
              aws elbv2 delete-load-balancer --load-balancer-arn "$LB_ARN" 2>/dev/null && echo "    ✓ Deleted" || echo "    ⚠ Failed or already deleted"
            done
            echo "Waiting 30 seconds for Load Balancers to be fully deleted..."
            sleep 30
          else
            echo "  ✓ No Load Balancers found"
          fi
          
          # 2. Desasociar y liberar Elastic IPs (debe hacerse ANTES de eliminar Network Interfaces)
          echo ""
          echo "Step 2: Checking for Elastic IPs..."
          if [ -n "$VPC_ID" ] && [ "$VPC_ID" != "None" ]; then
            # Buscar todas las Elastic IPs en la VPC
            EIP_INFO=$(aws ec2 describe-addresses \
              --filters "Name=domain,Values=vpc" \
              --query "Addresses[?NetworkInterfaceId!=null]" --output json 2>/dev/null || echo "[]")
            
            EIP_COUNT=$(echo "$EIP_INFO" | jq '. | length' 2>/dev/null || echo "0")
            if [ "$EIP_COUNT" -gt 0 ]; then
              echo "Found $EIP_COUNT Elastic IP(s) with network interfaces"
              echo "$EIP_INFO" | jq -r '.[] | "\(.AllocationId)|\(.AssociationId)"' | while IFS='|' read -r ALLOC_ID ASSOC_ID; do
                if [ -n "$ALLOC_ID" ] && [ "$ALLOC_ID" != "null" ]; then
                  # Verificar si la ENI asociada está en nuestra VPC
                  ENI_ID=$(aws ec2 describe-addresses --allocation-ids "$ALLOC_ID" --query "Addresses[0].NetworkInterfaceId" --output text 2>/dev/null || echo "")
                  if [ -n "$ENI_ID" ] && [ "$ENI_ID" != "None" ]; then
                    ENI_VPC=$(aws ec2 describe-network-interfaces --network-interface-ids "$ENI_ID" --query "NetworkInterfaces[0].VpcId" --output text 2>/dev/null || echo "")
                    if [ "$ENI_VPC" == "$VPC_ID" ]; then
                      echo "  → Processing Elastic IP: $ALLOC_ID"
                      if [ -n "$ASSOC_ID" ] && [ "$ASSOC_ID" != "null" ]; then
                        echo "    → Disassociating: $ASSOC_ID"
                        aws ec2 disassociate-address --association-id "$ASSOC_ID" 2>/dev/null && echo "      ✓ Disassociated" || echo "      ⚠ Failed"
                        sleep 1
                      fi
                      echo "    → Releasing: $ALLOC_ID"
                      aws ec2 release-address --allocation-id "$ALLOC_ID" 2>/dev/null && echo "      ✓ Released" || echo "      ⚠ Failed"
                    fi
                  fi
                fi
              done
            fi
            
            # También buscar Elastic IPs no asociadas
            UNASSOC_EIPS=$(aws ec2 describe-addresses \
              --filters "Name=domain,Values=vpc" \
              --query "Addresses[?AssociationId==null].AllocationId" \
              --output text 2>/dev/null || echo "")
            
            if [ -n "$UNASSOC_EIPS" ] && [ "$UNASSOC_EIPS" != "None" ]; then
              echo "Found unassociated Elastic IPs: $UNASSOC_EIPS"
              for EIP_ALLOC in $UNASSOC_EIPS; do
                echo "  → Releasing unassociated Elastic IP: $EIP_ALLOC"
                aws ec2 release-address --allocation-id "$EIP_ALLOC" 2>/dev/null && echo "    ✓ Released" || echo "    ⚠ Failed"
              done
            fi
            
            if [ "$EIP_COUNT" -eq 0 ] && [ -z "$UNASSOC_EIPS" ]; then
              echo "  ✓ No Elastic IPs found"
            fi
            sleep 5
          else
            echo "  ⚠ Cannot check Elastic IPs without VPC ID"
          fi
          
          # 3. Eliminar Network Interfaces residuales
          echo ""
          echo "Step 3: Checking for Network Interfaces..."
          if [ -n "$VPC_ID" ] && [ "$VPC_ID" != "None" ]; then
            # Buscar todas las network interfaces en la VPC (excepto las que están en uso por instancias activas)
            ENI_IDS=$(aws ec2 describe-network-interfaces \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query "NetworkInterfaces[?Status!='in-use' || Attachment.Status!='attached'].NetworkInterfaceId" \
              --output text 2>/dev/null || echo "")
            
            if [ -n "$ENI_IDS" ] && [ "$ENI_IDS" != "None" ]; then
              echo "Found Network Interfaces to clean: $ENI_IDS"
              for ENI_ID in $ENI_IDS; do
                echo "  → Processing Network Interface: $ENI_ID"
                # Obtener información de la ENI
                ATTACHMENT_ID=$(aws ec2 describe-network-interfaces --network-interface-ids "$ENI_ID" --query "NetworkInterfaces[0].Attachment.AttachmentId" --output text 2>/dev/null || echo "")
                if [ -n "$ATTACHMENT_ID" ] && [ "$ATTACHMENT_ID" != "None" ] && [ "$ATTACHMENT_ID" != "null" ]; then
                  echo "    → Detaching: $ATTACHMENT_ID"
                  aws ec2 detach-network-interface --attachment-id "$ATTACHMENT_ID" --force 2>/dev/null && echo "      ✓ Detached" || echo "      ⚠ Failed or already detached"
                  sleep 2
                fi
                echo "    → Deleting: $ENI_ID"
                aws ec2 delete-network-interface --network-interface-id "$ENI_ID" 2>/dev/null && echo "      ✓ Deleted" || echo "      ⚠ Failed or in use"
                sleep 1
              done
              sleep 10
            else
              echo "  ✓ No Network Interfaces found to clean"
            fi
          else
            echo "  ⚠ Cannot check Network Interfaces without VPC ID"
          fi
          
          echo ""
          echo "✓ Cleanup completed. Waiting 15 seconds for AWS to process all deletions..."
          sleep 15

      - name: Final cleanup before destroy (get VPC from subnets being deleted)
        run: |
          set +e
          echo "Final cleanup: Getting VPC ID from subnets that Pulumi is trying to delete..."
          
          # Buscar subnets con nombre "todo-vpc" que probablemente sean las que Pulumi está intentando eliminar
          SUBNETS=$(aws ec2 describe-subnets \
            --filters "Name=tag:Name,Values=*todo-vpc*" \
            --query "Subnets[*].[SubnetId,VpcId]" \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$SUBNETS" ]; then
            echo "Found subnets: $SUBNETS"
            # Obtener el VPC ID de la primera subnet
            VPC_ID=$(echo "$SUBNETS" | head -n1 | awk '{print $2}' || echo "")
            
            if [ -n "$VPC_ID" ] && [ "$VPC_ID" != "None" ]; then
              echo "✓ Found VPC ID from subnets: $VPC_ID"
              
              # Limpiar todas las Network Interfaces en estas subnets
              echo "Cleaning Network Interfaces in found subnets..."
              echo "$SUBNETS" | awk '{print $1}' | while read SUBNET_ID; do
                if [ -n "$SUBNET_ID" ]; then
                  ENI_IDS=$(aws ec2 describe-network-interfaces \
                    --filters "Name=subnet-id,Values=$SUBNET_ID" \
                    --query "NetworkInterfaces[?Status!='in-use'].NetworkInterfaceId" \
                    --output text 2>/dev/null || echo "")
                  
                  if [ -n "$ENI_IDS" ] && [ "$ENI_IDS" != "None" ]; then
                    echo "  Found ENIs in subnet $SUBNET_ID: $ENI_IDS"
                    for ENI_ID in $ENI_IDS; do
                      echo "    → Processing ENI: $ENI_ID"
                      # Desvincular si está asociada
                      ATTACHMENT_ID=$(aws ec2 describe-network-interfaces --network-interface-ids "$ENI_ID" --query "NetworkInterfaces[0].Attachment.AttachmentId" --output text 2>/dev/null || echo "")
                      if [ -n "$ATTACHMENT_ID" ] && [ "$ATTACHMENT_ID" != "None" ] && [ "$ATTACHMENT_ID" != "null" ]; then
                        echo "      → Detaching: $ATTACHMENT_ID"
                        aws ec2 detach-network-interface --attachment-id "$ATTACHMENT_ID" --force 2>/dev/null || true
                        sleep 1
                      fi
                      # Desasociar Elastic IP si tiene una
                      EIP_ALLOC=$(aws ec2 describe-network-interfaces --network-interface-ids "$ENI_ID" --query "NetworkInterfaces[0].Association.AllocationId" --output text 2>/dev/null || echo "")
                      if [ -n "$EIP_ALLOC" ] && [ "$EIP_ALLOC" != "None" ] && [ "$EIP_ALLOC" != "null" ]; then
                        ASSOC_ID=$(aws ec2 describe-network-interfaces --network-interface-ids "$ENI_ID" --query "NetworkInterfaces[0].Association.AssociationId" --output text 2>/dev/null || echo "")
                        if [ -n "$ASSOC_ID" ] && [ "$ASSOC_ID" != "None" ] && [ "$ASSOC_ID" != "null" ]; then
                          echo "      → Disassociating Elastic IP: $ASSOC_ID"
                          aws ec2 disassociate-address --association-id "$ASSOC_ID" 2>/dev/null || true
                          sleep 1
                          echo "      → Releasing Elastic IP: $EIP_ALLOC"
                          aws ec2 release-address --allocation-id "$EIP_ALLOC" 2>/dev/null || true
                        fi
                      fi
                      # Eliminar la ENI
                      echo "      → Deleting ENI: $ENI_ID"
                      aws ec2 delete-network-interface --network-interface-id "$ENI_ID" 2>/dev/null && echo "        ✓ Deleted" || echo "        ⚠ Failed or in use"
                      sleep 1
                    done
                  fi
                fi
              done
              
              # Limpiar todas las Elastic IPs asociadas a Network Interfaces en esta VPC
              echo "Cleaning Elastic IPs in VPC: $VPC_ID"
              ALL_EIPS=$(aws ec2 describe-addresses \
                --filters "Name=domain,Values=vpc" \
                --query "Addresses[?NetworkInterfaceId!=null]" \
                --output json 2>/dev/null || echo "[]")
              
              echo "$ALL_EIPS" | jq -r '.[] | "\(.AllocationId)|\(.AssociationId)|\(.NetworkInterfaceId)"' | while IFS='|' read -r ALLOC_ID ASSOC_ID ENI_ID; do
                if [ -n "$ENI_ID" ] && [ "$ENI_ID" != "null" ]; then
                  ENI_VPC=$(aws ec2 describe-network-interfaces --network-interface-ids "$ENI_ID" --query "NetworkInterfaces[0].VpcId" --output text 2>/dev/null || echo "")
                  if [ "$ENI_VPC" == "$VPC_ID" ]; then
                    echo "  → Processing Elastic IP: $ALLOC_ID"
                    if [ -n "$ASSOC_ID" ] && [ "$ASSOC_ID" != "null" ]; then
                      echo "    → Disassociating: $ASSOC_ID"
                      aws ec2 disassociate-address --association-id "$ASSOC_ID" 2>/dev/null || true
                      sleep 1
                    fi
                    echo "    → Releasing: $ALLOC_ID"
                    aws ec2 release-address --allocation-id "$ALLOC_ID" 2>/dev/null || true
                  fi
                fi
              done
              
              echo "Waiting 10 seconds for AWS to process..."
              sleep 10
            fi
          else
            echo "No subnets found with 'todo-vpc' in name"
          fi

      - name: Destroy infrastructure
        working-directory: pulumi-aws
        env:
          PULUMI_ACCESS_TOKEN: ${{ env.PULUMI_ACCESS_TOKEN }}
          PULUMI_K8S_DELETE_UNREACHABLE: "true"
        run: |
          set +e
          echo "Starting destroy operation..."
          pulumi destroy --yes --skip-preview
          EXIT_CODE=$?
          
          # Si falla por dependencias, intentar limpiar una vez más y reintentar
          if [ $EXIT_CODE -ne 0 ]; then
            echo "Destroy failed with exit code $EXIT_CODE"
            echo "Checking if it's a dependency error..."
            
            if [ $EXIT_CODE -eq 255 ]; then
              # Error 404 significa que el stack no existe o ya fue eliminado
              echo "Stack may have already been destroyed (404 error). Checking..."
              pulumi stack select dev 2>&1 | grep -q "404" && echo "Stack already destroyed. Exiting successfully." && exit 0
            fi
            
            # Si el error es por dependencias (DependencyViolation), esperar un poco y reintentar
            echo "Waiting 30 seconds and retrying destroy..."
            sleep 30
            echo "Retrying destroy..."
            pulumi destroy --yes --skip-preview
            EXIT_CODE=$?
          fi
          
          exit $EXIT_CODE

      - name: Show destroyed resources
        working-directory: pulumi-aws
        env:
          PULUMI_ACCESS_TOKEN: ${{ env.PULUMI_ACCESS_TOKEN }}
        run: pulumi stack --show-urns || echo "Stack destroyed or empty"
